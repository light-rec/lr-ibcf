// Comments generated by ChatGPT

import { cosineSimilarity } from "./utils.js";
import Heap from './heap.js';

/**
 * RecEngine class
 * Implements an item-based collaborative filtering recommendation system
 */
export class LightRec {
    constructor() {
        this.itemUserMatrix = {}; // { itemId: { userId: points } }
        this.itemMatrix = {};     // { itemId: { similarItemId: similarity } }
    }

    /**
     * Record or update a user's interaction with an item
     * @param {string} itemId 
     * @param {string} userId 
     * @param {number} points 
     * @param {boolean} modify - whether to update item similarity after act
     */
    act(itemId, userId, points, modify = true) {
        if (typeof points !== "number") {
            throw Error(`Points must be a number. Data: ${itemId}, ${userId}, ${points}`);
        }
        if (points === 0) return;

        // Add or update the points for this item-user pair
        if (!this.itemUserMatrix[itemId]) this.itemUserMatrix[itemId] = {};
        if (this.itemUserMatrix[itemId][userId]) {
            this.itemUserMatrix[itemId][userId] += points;
        } else {
            this.itemUserMatrix[itemId][userId] = points;
        }

        // Update similarity matrix if needed
        if (modify) {
            const start = performance.now();
            this.modifyItemSimilarity(itemId);
            const end = performance.now();
        }
    }

    /**
     * Feed a batch of interactions into the engine
     * @param {Array} data - array of {itemId, userId, points}
     */
    feed(data) {
        const startTime = performance.now();

        const actStart = performance.now();
        for (const i of data) {
            this.act(i.itemId, i.userId, i.points, false);
        }
        const actEnd = performance.now();

        const simStart = performance.now();
        this.buildItemSimilarity();
        const simEnd = performance.now();

        const endTime = performance.now();
    }

    /**
     * Update the similarity row/column for a single item
     * @param {string} item 
     */
    modifyItemSimilarity(item) {
        if (!this.itemMatrix[item]) this.itemMatrix[item] = {};
        const heap = new Heap();

        for (const key in this.itemMatrix) {
            if (key !== item) {
                const s = cosineSimilarity(this.itemUserMatrix[item], this.itemUserMatrix[key]);
                heap.insert({ key, similarity: s });
            }
        }

        const map = {};
        for (const i of heap.getHeap()) {
            map[i.key] = i.similarity;
        }
        this.itemMatrix[item] = map;

        // Keep symmetric similarity
        for (const key in map) {
            if (!this.itemMatrix[key]) this.itemMatrix[key] = {};
            this.itemMatrix[key][item] = map[key];
        }
    }

    /**
     * Build the full similarity matrix for all items
     */
    buildItemSimilarity() {
        for (const key in this.itemUserMatrix) {
            if (!this.itemMatrix[key]) this.itemMatrix[key] = {};
            const heap = new Heap();

            for (const key2 in this.itemUserMatrix) {
                if (!this.itemMatrix[key2]) this.itemMatrix[key2] = {};
                if (key !== key2) {
                    const s = cosineSimilarity(this.itemUserMatrix[key], this.itemUserMatrix[key2]);
                    heap.insert({ key: key2, similarity: s });
                }
            }

            const map = {};
            for (const i of heap.getHeap()) {
                map[i.key] = i.similarity;
            }
            this.itemMatrix[key] = map;
        }
    }

    /**
     * Recommend items for a given user
     * @param {string} userId 
     * @param {number} topN - number of items to recommend
     * @returns {Array} recommended items [{itemId}]
     */
    recommendForUser(userId, topN = 10) {
        const userHistory = {}; // items the user has interacted with

        // Step 1: Get user's history
        for (const itemId in this.itemUserMatrix) {
            if (userId in this.itemUserMatrix[itemId]) {
                userHistory[itemId] = this.itemUserMatrix[itemId][userId];
            }
        }

        // Step 2: Aggregate candidate scores
        const scores = {};
        for (const [itemId, points] of Object.entries(userHistory)) {
            const similarItems = this.itemMatrix[itemId] || {};
            for (const [simItemId, similarity] of Object.entries(similarItems)) {
                if (userHistory[simItemId]) continue; // skip items already seen
                if (!scores[simItemId]) scores[simItemId] = 0;
                scores[simItemId] += similarity * points;
            }
        }

        // Step 3: Sort and return top-N
        return Object.entries(scores)
            .sort((a, b) => b[1] - a[1])
            .slice(0, topN)
            .map(([itemId]) => (itemId));
    }

    /**
     * Print the item-user matrix
     */
    printItemUserMatrix() {
        for (const key in this.itemUserMatrix) {
            const vector = this.itemUserMatrix[key] || {};
            let val = '{';
            for (const k in vector) {
                val += `${k}:${vector[k]} `;
            }
            val += '}';
        }
    }
}
